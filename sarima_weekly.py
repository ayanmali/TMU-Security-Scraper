"""
Generates a forecast of the total number of incidents over time.
"""

from locationclassifier import process_dates
from sqlalchemy import create_engine
import sys
sys.path.insert(1, 'c:/Users/ayan_/Desktop/Desktop/Coding/Cursor Workspace/Scrapers')
from postgres_params import user, password, host, port, dbname
import pandas as pd
from matplotlib import pyplot as plt
import mpld3
import matplotlib.dates as mdates
from matplotlib.ticker import MaxNLocator
import pickle

from statsmodels.tsa.stattools import adfuller
import pmdarima as pm
from statsmodels.tsa.seasonal import seasonal_decompose

TABLE_NAME = "incidents"
NUM_STEPS = 52

def visualize_time_series(incident_series):
    # Create the figure
    fig, ax = plt.subplots(figsize=(15, 6))

    # Plot the data

    # Calculate moving average (8-week window)
    moving_avg = incident_series.rolling(window=8).mean()

    # Plot both the actual data and moving average
    ax.plot(incident_series.index, incident_series.values, 
            label='Monthly Incidents', color='#2E86C1', alpha=0.6)
    ax.plot(moving_avg.index, moving_avg.values, 
            label='8-Week Moving Average', color='#E74C3C', linewidth=2)

    # Fill the area under the curve
    ax.fill_between(incident_series.index, incident_series.values, 
                    alpha=0.2, color='#2E86C1')

    # Customize the plot
    ax.set_title('Count of TMU Campus Security Incidents Per Week', fontsize=14, pad=15)
    ax.set_xlabel('Date', fontsize=12)
    ax.set_ylabel('Number of Incidents', fontsize=12)

    # Format y-axis to show whole numbers only
    ax.yaxis.set_major_locator(MaxNLocator(integer=True))

    # Rotate x-axis labels
    plt.xticks(rotation=45)

    # Add grid
    ax.grid(True, linestyle='--', alpha=0.7)

    # Add legend
    ax.legend()

    # Add padding
    plt.tight_layout()

    # Show the plot
    plt.show()

def decompose(weekly_incidents):
     # Breaking down the time series into seasonal patterns, using a season period of 52 (i.e. 52 weeks = 1 year)
     result = seasonal_decompose(weekly_incidents, model='additive', period=NUM_STEPS)
     trend = result.trend.dropna()
     seasonal = result.seasonal.dropna()
     residual = result.resid.dropna()

     # Plot the decomposed components
     plt.figure(figsize=(6,6))

     plt.subplot(4, 1, 1)
     plt.plot(weekly_incidents, label='Original Series')
     plt.legend()

     plt.subplot(4, 1, 2)
     plt.plot(trend, label='Trend')
     plt.legend()

     plt.subplot(4, 1, 3)
     plt.plot(seasonal, label='Seasonal')
     plt.legend()

     plt.subplot(4, 1, 4)
     plt.plot(residual, label='Residuals')
     plt.legend()

     plt.tight_layout()
     plt.show()

def create_model(weekly_incidents):
     sarima = pm.auto_arima(weekly_incidents,
                           start_p=1, start_q=1,
                           test='adf',
                           max_p=3, max_q=3, m=12,
                           start_P=0, seasonal=True,
                           d=None, D=1,
                           trace=False,
                           error_action='ignore',
                           suppress_warnings=True,
                           stepwise=True)
     
     return sarima 

"""
Uses the SARIMA model to generate a forecasted time series.
"""
def forecast_incidents(weekly_incidents, sarima, forecast_steps=NUM_STEPS):
    # Generate forecast
    forecast, conf_int = sarima.predict(n_periods=forecast_steps, return_conf_int=True)
    
    # Create a date range for the forecast periods
    last_date = weekly_incidents.index[-1]
    forecast_dates = pd.date_range(start=last_date + pd.Timedelta(weeks=1), 
                                    periods=forecast_steps, 
                                    freq='W')
    
    # Convert forecast to a pandas Series with appropriate index
    forecast_series = pd.Series(forecast, index=forecast_dates)
    
    return forecast_series, conf_int

"""
Creates an HTML plot showing the predicted time series generated by the model.
"""
def plot_forecast(weekly_incidents, forecast_series, conf_int=None):
    # Create the figure
    fig, ax = plt.subplots(figsize=(15,7))
    plt.figure(figsize=(15, 7))
    
    # Plot the original time series
    historical_line, = ax.plot(weekly_incidents.index, weekly_incidents.values, 
             label='Historical Weekly Incidents', color='#2E86C1', alpha=0.7)
    
    # Add tooltips for historical data
    historical_tooltip = mpld3.plugins.PointLabelTooltip(
        historical_line, 
        labels=[f'Date: {date.strftime("%Y-%m-%d")}\nIncidents: {value}' 
                for date, value in zip(weekly_incidents.index, weekly_incidents.values)]
    )
    
    # Plot the forecast
    forecast_line, = ax.plot(forecast_series.index, forecast_series.values, 
             label='Forecasted Incidents', color='#E74C3C', linestyle='--')

    # Add tooltips for forecast data
    forecast_tooltip = mpld3.plugins.PointLabelTooltip(
        forecast_line, 
        labels=[f'Date: {date.strftime("%Y-%m-%d")}\nForecast: {value:.2f}' 
                for date, value in zip(forecast_series.index, forecast_series.values)]
    )
    
    # Plot confidence intervals if provided
    if conf_int is not None:
        confidence_area = ax.fill_between(forecast_series.index, 
                         conf_int[:, 0], conf_int[:, 1], 
                         color='#E74C3C', alpha=0.2, 
                         label='95% Confidence Interval')
    
    # Customize the plot
    ax.set_title('TMU Campus Security Incidents: Historical and Forecast', fontsize=14, pad=15)
    ax.set_xlabel('Date', fontsize=12)
    ax.set_ylabel('Number of Incidents', fontsize=12)
    
    # Format y-axis to show whole numbers only
    # plt.gca().yaxis.set_major_locator(MaxNLocator(integer=True))
    ax.yaxis.set_major_locator(MaxNLocator(integer=True))
    
    # Rotate x-axis labels
    plt.xticks(rotation=45)
    
    # Add grid
    ax.grid(True, linestyle='--', alpha=0.7)
    
    # Add legend
    ax.legend()
    
    # Add padding
    plt.tight_layout()

    # Install mpld3 plugins
    mpld3.plugins.connect(fig, historical_tooltip)
    mpld3.plugins.connect(fig, forecast_tooltip)

    # Show the plot
    fig.show()
    
    # Convert to interactive HTML
    return mpld3.fig_to_html(fig)

def save_html(html, filename="sarima_weekly_forecast.html"):
    # Saving it in the folder containing the Django API views
    with open(f'django_api/{filename}', 'w') as f:
        f.write(html)
    print(f"Interactive visualization saved to {filename}")

def main():
        print("Loading the data...")
        engine = create_engine(f'postgresql://{user}:{password}@{host}:{port}/{dbname}')
        df = pd.read_sql(f"SELECT * FROM {TABLE_NAME}", engine)

        _, _, daily_incidents = process_dates(df)

        # Obtaining the total number of incidents that occurred each week
        weekly_incidents = daily_incidents.resample('W').sum()
        print(weekly_incidents.index)

        # visualize_time_series(weekly_incidents)

        # Subtracting a lagged version of the time series from itself (1 month lag)
        # weekly_diff = weekly_incidents.diff(periods=4)
        # weekly_diff.dropna(inplace=True)

        # visualize_time_series(weekly_diff)

        # print(weekly_incidents.index.month)

        # Create and fit the SARIMA model
        # sarima_model = create_model(weekly_incidents)

        # Saving the model
        # with open('django_api/sarima_weekly.pkl', 'wb') as file:
            # pickle.dump(sarima_model, file)
        
        # Generate forecast
        # forecast_series, conf_int = forecast_incidents(weekly_incidents, sarima_model)
        
        # Plot the forecast
        # plot_forecast(weekly_incidents, forecast_series, conf_int)

        # save_html(html)
        
        # Optional: print out the forecast values
        # print("\nForecast for the next 12 weeks:")
        # print(forecast_series)

if __name__ == "__main__":
    main()